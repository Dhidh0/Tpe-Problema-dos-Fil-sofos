#!/usr/bin/env python3
"""
Simulação do problema "Jantar dos Filósofos".
Estratégia para evitar deadlock: usa um "garçom" (Semaphore) que permite no máximo N-1
filósofos tentarem pegar hashis ao mesmo tempo.
"""

import threading
import time
import random

NUM_PHILOSOPHERS = 5
ITERATIONS = 5  # quantas vezes cada filósofo vai tentar comer

print_lock = threading.Lock()  # evita prints embaralhados


class Philosopher(threading.Thread):
    def __init__(self, id_, left_fork, right_fork, waiter, iterations=ITERATIONS):
        super().__init__(daemon=True)
        self.id = id_
        self.left = left_fork
        self.right = right_fork
        self.waiter = waiter
        self.iterations = iterations

    def log(self, msg):
        with print_lock:
            print(f"[F{self.id}] {msg}")

    def think(self):
        t = random.uniform(0.1, 0.6)
        self.log(f"pensando por {t:.2f}s")
        time.sleep(t)

    def eat(self):
        t = random.uniform(0.2, 0.7)
        self.log(f"comendo por {t:.2f}s")
        time.sleep(t)

    def run(self):
        for i in range(self.iterations):
            self.think()

            # pedir permissão ao garçom: limita concorrência para evitar deadlock
            self.log("pede permissão ao garçom")
            self.waiter.acquire()
            try:
                # pega os dois hashis (locks). ordem fixa: esquerda depois direita
                self.log("tentando pegar hashi esquerdo")
                with self.left:
                    self.log("pegou hashi esquerdo")
                    self.log("tentando pegar hashi direito")
                    with self.right:
                        self.log("pegou hashi direito — começando a comer")
                        self.eat()
                        self.log("terminou de comer — soltando hashis")
            finally:
                self.waiter.release()

        self.log("terminou todas as iterações")


def main(num_philosophers=NUM_PHILOSOPHERS, iterations=ITERATIONS):
    forks = [threading.Lock() for _ in range(num_philosophers)]
    waiter = threading.Semaphore(num_philosophers - 1)  # permite até N-1 filósofos tentarem ao mesmo tempo

    philosophers = []
    for i in range(num_philosophers):
        left = forks[i]
        right = forks[(i + 1) % num_philosophers]
        p = Philosopher(i + 1, left, right, waiter, iterations=iterations)
        philosophers.append(p)

    for p in philosophers:
        p.start()

    # aguardar todos terminarem
    for p in philosophers:
        p.join()


if __name__ == "__main__":
    main()
